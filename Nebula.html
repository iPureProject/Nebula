<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AiLov AI — Nebula Console (stabile)</title>
<style>
  :root{ --bg:#0b0f14; --fg:#e8eef9; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
    font:500 16px/1.5 Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{width:min(1000px,92vw); aspect-ratio:16/10; margin:4vh auto; position:relative;
    border-radius:18px; overflow:hidden;
    box-shadow:0 10px 40px rgba(0,0,0,.55), inset 0 0 0 1px rgba(255,255,255,.04);
    background:radial-gradient(1000px 800px at 20% 10%, #0f1520 0%, #0b0f14 60%, #090d12 100%);}
  header{position:absolute; inset:14px auto auto 16px; z-index:2; font-weight:700; letter-spacing:.2px}
  canvas{display:block; width:100%; height:100%}
  .bubble{position:absolute; left:50%; bottom:18px; transform:translateX(-50%); z-index:2;
    background:rgba(12,16,24,.55); padding:10px 14px; border-radius:14px;
    backdrop-filter:blur(6px); -webkit-backdrop-filter:blur(6px);
    border:1px solid rgba(255,255,255,.06); font-weight:600}
</style>
</head>
<body>
  <div class="wrap">
    <header>AiLov AI — Nebula Console</header>
    <canvas id="nebula"></canvas>
    <div class="bubble">Ciao! Sono <b>AiLov</b>. Parliamo? ✨</div>
  </div>

<script>
/* ====================== PARAMETRI ====================== */
const PARTICLES       = 320;     // 200–600
const MAX_LINKS_NODE  = 3;       // connessioni eleganti
const LINK_RADIUS_FR  = 0.40;    // raggio connessioni (× baseR)
const NODE_SIZE       = 1.2;     // px (prima del DPR)
const LINE_ALPHA_BASE = 0.1;    // opacità linee
const LINE_ALPHA_PULSE= 0.1;    // extra durante il battito
const SAT             = 95;      // saturazione HSL dei punti
const LUM             = 70;      // luminosità media HSL
const CORE_STRENGTH   = 1.2;     // intensità bagliore centrale (0.6–1.4)

const PULSE_HZ        = 0.85;    // 0.7–1.1 → cuore calmo
const PULSE_AMPL      = 0.050;   // 0.03–0.07 → respiro morbido
const JITTER_FRAC     = 0.012;   // piccolo tremolio organico (× baseR)
const DPR_CAP         = 2;       // per iPad performance
/* ====================================================== */

const cvs = document.getElementById('nebula');
const ctx = cvs.getContext('2d');

let w=0,h=0,cx=0,cy=0, baseR=0, dpr=1;

// Nodi “stabili”: memorizziamo solo r0, theta, hue, seed
const nodes = [];
function resize(){
  const rect = cvs.getBoundingClientRect();
  dpr = Math.min(window.devicePixelRatio||1, DPR_CAP);
  cvs.width  = Math.max(320, Math.floor(rect.width  * dpr));
  cvs.height = Math.max(240, Math.floor(rect.height * dpr));
  cvs.style.width  = rect.width +"px";
  cvs.style.height = rect.height+"px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
  w = rect.width; h = rect.height; cx = w/2; cy = h/2;
  baseR = Math.min(w,h) * 0.38; // raggio visivo della sfera
}
function spawn(){
  nodes.length = 0;
  for(let i=0;i<PARTICLES;i++){
    const u = Math.random();                   // 0..1
    const v = Math.random();
    const r0 = Math.sqrt(u) * (baseR*0.98);    // uniforme nel disco
    const th = 2*Math.PI*v;
    const hue = (th*180/Math.PI + 360)%360;
    nodes.push({ r0, th, hue, seed: Math.random()*1000 });
  }
}
window.addEventListener('resize', ()=>{ resize(); spawn(); }, {passive:true});
resize(); spawn();

// Battito SIN → niente “risucchio”
function pulseAt(t){
  return 1 + PULSE_AMPL * Math.sin(2*Math.PI*PULSE_HZ*t);
}

// Disegno: tutto avviene DENTRO una clip circolare (niente bordo quadrato)
function clipCircle(radius){
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI*2);
  ctx.clip();
}

function drawCoreGlow(p){
  const r = baseR * 1.15 * p;
  const g = ctx.createRadialGradient(cx,cy, r*0.06, cx,cy, r);
  const F = CORE_STRENGTH;
  g.addColorStop(0.00, `rgba(255,220,140,${0.32*F})`);
  g.addColorStop(0.35, `rgba(240,110,200,${0.22*F})`);
  g.addColorStop(0.65, `rgba(110,160,255,${0.16*F})`);
  g.addColorStop(1.00, `rgba(30,40,60,0.00)`);
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
}

function framePositions(t, p){
  // calcola posizioni “istantanee” (nessuna velocità cumulativa → niente buco nero)
  const jitterAmp = baseR * JITTER_FRAC;
  const out = new Array(nodes.length);
  for(let i=0;i<nodes.length;i++){
    const n = nodes[i];
    const r  = n.r0 * p;                 // respiro radiale
    const jx = Math.sin(t*1.3 + n.seed) * jitterAmp;
    const jy = Math.cos(t*1.7 + n.seed) * jitterAmp;
    const x = cx + Math.cos(n.th)*r + jx;
    const y = cy + Math.sin(n.th)*r + jy;
    out[i] = {x,y,hue:n.hue};
  }
  return out;
}

function drawLinks(pts, p){
  const linkR = baseR * LINK_RADIUS_FR;
  const aBase = LINE_ALPHA_BASE + LINE_ALPHA_PULSE*(p-1)/PULSE_AMPL * 0.5;
  ctx.lineWidth = Math.max(1, 0.9*dpr);
  for(let i=0;i<pts.length;i++){
    let links=0;
    const a = pts[i];
    for(let j=i+1;j<pts.length && links<MAX_LINKS_NODE;j++){
      const b = pts[j];
      const dx=a.x-b.x, dy=a.y-b.y; const d=Math.hypot(dx,dy);
      if(d<linkR){
        const t = 1 - d/linkR; // più vicino → più visibile
        ctx.strokeStyle = `rgba(170,190,230,${(aBase*(0.25+t*0.75)).toFixed(3)})`;
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
        links++;
      }
    }
  }
}

function drawNodes(pts, p){
  const r = NODE_SIZE * dpr;
  ctx.shadowColor = 'rgba(255,255,255,0.25)';
  ctx.shadowBlur  = 8 * dpr * (0.9 + 0.2*(p-1)/PULSE_AMPL);
  for(const q of pts){
    // HSL “arcobaleno elegante”
    ctx.fillStyle = `hsl(${q.hue.toFixed(1)} ${SAT}% ${LUM + 10*(p-1)/PULSE_AMPL}%)`;
    ctx.beginPath(); ctx.arc(q.x,q.y,r,0,Math.PI*2); ctx.fill();
  }
  ctx.shadowBlur = 0;
}

// Loop
let last = performance.now()/1000;
function step(){
  const now = performance.now()/1000;
  const dt  = Math.min(0.033, now-last); last = now;
  const p   = pulseAt(now);

  // reset
  ctx.clearRect(0,0,w,h);

  // clip circolare all’inizio del frame → mai bordi quadrati
  clipCircle(baseR * 1.06 * p);

  // alone centrale
  drawCoreGlow(p);

  // posizioni istantanee (nessuna deriva)
  const pts = framePositions(now, p);

  // connessioni e punti
  drawLinks(pts, p);
  drawNodes(pts, p);

  // chiudi clip
  ctx.restore();

  requestAnimationFrame(step);
}
requestAnimationFrame(step);
</script>
</body>
</html>
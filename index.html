<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AiLov Nebula Console</title>
<style>
  :root{ --bg0:#05070b; --bg1:#071020; --fg:#e9eefb; }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 900px at 20% 10%, var(--bg1) 0%, var(--bg0) 55%, #00050a 100%);
    color:var(--fg); font:500 16px/1.5 Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  /* evitiamo aspect-ratio: altezza esplicita → funziona anche su preview iPad */
  .wrap{
    width:min(1100px, 94vw);
    height:min(720px, 72vh);
    margin:4vh auto; position:relative; border-radius:18px; overflow:hidden;
    box-shadow:0 10px 40px rgba(0,0,0,.55), inset 0 0 0 1px rgba(255,255,255,.04);
    background: radial-gradient(900px 700px at 50% 50%, #0a1324 0%, #060a12 65%, #04070c 100%);
  }
  header{position:absolute; inset:14px auto auto 16px; z-index:2; font-weight:700; letter-spacing:.2px}
  .hint{position:absolute; left:50%; bottom:18px; transform:translateX(-50%); z-index:2;
        background:rgba(10,14,22,.55); border:1px solid rgba(255,255,255,.06);
        padding:10px 14px; border-radius:14px; backdrop-filter:blur(6px); -webkit-backdrop-filter:blur(6px);
        font-weight:600}
  canvas{position:absolute; inset:0; width:100%; height:100%; display:block}
  .msg{ padding:10px 12px; border-radius:12px; line-height:1.35; max-width:90%;}
.msg.you{ align-self:flex-end; background:rgba(255,255,255,.08);}
.msg.ai{  align-self:flex-start; background:rgba(20,28,44,.7); border:1px solid rgba(255,255,255,.06);}
</style>
</head>
<body>
  <div class="wrap">
    <header>AiLov Nebula Console</header>
    <canvas id="nebula"></canvas>
    <div id="overlay-card" style="display:none; position:absolute; top:10%; left:10%; right:10%; background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.3); border-radius:20px; padding:20px; color:white; font-family:sans-serif;">
  <h2 id="node-name"></h2>
  <button id="closeCard" style="background:none; border:1px solid white; color:white; border-radius:10px; padding:6px 12px;">Chiudi</button>
</div>
    <div class="hint">Ciao! Sono <b>AiLov</b>. Parliamo? ✨</div>
<!-- Chat dock minimale -->
<div id="dock" style="position:absolute; right:14px; bottom:14px; width:min(360px, 92vw); z-index:6;
                      background:rgba(8,12,20,.65); border:1px solid rgba(255,255,255,.08);
                      border-radius:14px; backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);
                      box-shadow:0 10px 30px rgba(0,0,0,.45); overflow:hidden;">
  <div id="dock-messages" style="max-height:38vh; overflow:auto; padding:10px 12px; gap:8px; display:flex; flex-direction:column;"></div>
  <div style="display:flex; gap:8px; padding:10px; border-top:1px solid rgba(255,255,255,.06);">
    <input id="dock-input" type="text" placeholder="Scrivi a AiLov…" autocomplete="off"
           style="flex:1; background:rgba(255,255,255,.06); color:#e9eefb; border:1px solid rgba(255,255,255,.08);
                  border-radius:10px; padding:10px 12px; outline:none;" />
    <button id="dock-send"
            style="background:#2f7af8; color:white; border:none; border-radius:10px; padding:10px 14px; font-weight:600;">
      Invia
    </button>
  </div>
</div>
<script>
/* ====================== PARAMETRI ====================== */
const PARTICLES        = 420;      // nodi (più alto = più denso)
const MAX_LINKS_NODE   = 3;        // connessioni eleganti per nodo
const LINK_RADIUS_FR   = 0.20;     // raggio connessioni (× baseR)
const NODE_SIZE        = 1.2;      // raggio puntini (piccoli)
const LINE_ALPHA_BASE  = 0.12;     // opacità linee base
const LINE_ALPHA_PULSE = 0.08;     // extra durante il battito
const SAT              = 92;       // saturazione HSL (vivace)
const LUM              = 66;       // luminosità media HSL
const CORE_STRENGTH    = 1.05;     // intensità glow centrale

// Battito calmo
const PULSE_HZ   = 0.85;           // 0.7–1.1
const PULSE_AMPL = 0.045;          // 0.03–0.07
const JITTER_FR  = 0.010;          // micro tremolio (× baseR)
const RADIUS_FR  = 0.38;           // raggio sfera vs lato min
const DPR_CAP    = 2;              // per iPad performance
/* ====================================================== */

const cvs = document.getElementById('nebula');
const ctx = cvs.getContext('2d');

let w=0,h=0,cx=0,cy=0, baseR=0, dpr=1;

function resize(){
  const rect = cvs.parentElement.getBoundingClientRect();
  dpr = Math.min(window.devicePixelRatio||1, DPR_CAP);
  cvs.width  = Math.max(320, Math.floor(rect.width  * dpr));
  cvs.height = Math.max(240, Math.floor(rect.height * dpr));
  cvs.style.width  = rect.width +"px";
  cvs.style.height = rect.height+"px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
  w = rect.width; h = rect.height; cx = w/2; cy = h/2;
  baseR = Math.min(w,h) * RADIUS_FR;
}
window.addEventListener('resize', ()=>{ resize(); spawn(); }, {passive:true});

/* punti stabili: memorizziamo r0 + theta + seed (niente deriva cumulativa) */
const nodes=[];
function spawn(){
  nodes.length=0;
  for(let i=0;i<PARTICLES;i++){
    const u = Math.random(), v = Math.random();
    const r0 = Math.sqrt(u) * (baseR*0.98);    // uniforme nel disco
    const th = 2*Math.PI*v;
    const hue= (th*180/Math.PI + 360)%360;     // arcobaleno da angolo
    nodes.push({r0: r0, th: th, hue: hue, seed: Math.random()*1000});
  }
}
resize(); spawn();

// battito sinusoidale → niente “buco nero”
const TAU = Math.PI*2;
function pulseAt(t){ return 1 + PULSE_AMPL * Math.sin(TAU*PULSE_HZ*t); }

// clip circolare all’inizio di ogni frame
function clipCircle(radius){
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, TAU);
  ctx.clip();
}

// glow centrale (nero-blu profondo intorno)
function drawCoreGlow(p){
  const r = baseR * 1.18 * p;
  const g = ctx.createRadialGradient(cx,cy, r*0.06, cx,cy, r);
  const F = CORE_STRENGTH;
  g.addColorStop(0.00, `rgba(255,220,140,${0.30*F})`);
  g.addColorStop(0.30, `rgba(240,110,200,${0.22*F})`);
  g.addColorStop(0.65, `rgba(110,160,255,${0.16*F})`);
  g.addColorStop(1.00, `rgba(10,18,36,0.00)`);
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(cx,cy,r,0,TAU); ctx.fill();
}

function framePositions(t, p){
  const jitter = baseR * JITTER_FR;
  const out = new Array(nodes.length);
  for(let i=0;i<nodes.length;i++){
    const n = nodes[i];
    const r = n.r0 * p;
    const jx = Math.sin(t*1.25 + n.seed) * jitter;
    const jy = Math.cos(t*1.55 + n.seed) * jitter;
    const x = cx + Math.cos(n.th)*r + jx;
    const y = cy + Math.sin(n.th)*r + jy;
    out[i] = {x,y,hue:n.hue};
  }
  return out;
}

function drawLinks(pts, p){
  const linkR = baseR * LINK_RADIUS_FR;
  const aBase = LINE_ALPHA_BASE + LINE_ALPHA_PULSE * (p-1)/PULSE_AMPL * 0.5;
  ctx.lineWidth = Math.max(1, 0.9*dpr);
  for(let i=0;i<pts.length;i++){
    let links=0;
    const a = pts[i];
    for(let j=i+1;j<pts.length && links<MAX_LINKS_NODE;j++){
      const b = pts[j];
      const dx=a.x-b.x, dy=a.y-b.y; const d=Math.hypot(dx,dy);
      if(d<linkR){
        const t = 1 - d/linkR;
        ctx.strokeStyle = `hsla(${((a.hue+b.hue)/2).toFixed(1)}, 85%, 75%, ${(aBase*(0.25+t*0.75)).toFixed(3)})`;
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
        links++;
      }
    }
  }
}

function drawNodes(pts, p){
  const r = NODE_SIZE * dpr; // piccoli ma luminosi
  ctx.shadowColor = 'rgba(255,255,255,0.28)';
  ctx.shadowBlur  = 7 * dpr * (0.9 + 0.2*(p-1)/PULSE_AMPL);
  for(const q of pts){
    ctx.fillStyle = `hsl(${q.hue.toFixed(1)} ${SAT}% ${LUM + 10*(p-1)/PULSE_AMPL}%)`;
    ctx.beginPath(); ctx.arc(q.x,q.y,r,0,TAU); ctx.fill();
  }
  ctx.shadowBlur = 0;
}

// loop
let last = performance.now()/1000;
function step(){
  const now = performance.now()/1000;
  const p   = pulseAt(now);

  ctx.clearRect(0,0,cvs.width,cvs.height);
  clipCircle(baseR * 1.06 * p);   // cerchio perfetto

  drawCoreGlow(p);

  const pts = framePositions(now, p);
  drawLinks(pts, p);
  drawNodes(pts, p);

  ctx.restore();                  // chiude la clip
  requestAnimationFrame(step);
}
requestAnimationFrame(step);
  // Finestra trasparente (overlay) 

/* === Overlay behaviour (popup) === */
const card     = document.getElementById('overlay-card');
const nameEl   = document.getElementById('node-name');
const closeBtn = document.getElementById('closeCard');

cvs.addEventListener('click', (event) => {
  const rect = cvs.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  card.style.left = `${x + 12}px`;
  card.style.top  = `${y + 12}px`;
  card.style.display = 'block';
  nameEl.textContent = 'Nodo selezionato ✨';
});

closeBtn.addEventListener('click', () => {
  card.style.display = 'none';
});

// Chiudi la finestra
closeBtn.addEventListener('click', () => {
  card.style.display = 'none';
});
// ========== AiLov: chat locale minimale con memoria ==========
(function(){
  const $msgs = document.getElementById('dock-messages');
  const $in   = document.getElementById('dock-input');
  const $send = document.getElementById('dock-send');

  // memoria in localStorage
  const KEY = 'ailov_mem_v1';
  const mem = loadMem();

  function loadMem(){
    try{ return JSON.parse(localStorage.getItem(KEY)) || {name:null, likes:[], hates:[], notes:[]} }
    catch{ return {name:null, likes:[], hates:[], notes:[]} }
  }
  function saveMem(){ localStorage.setItem(KEY, JSON.stringify(mem)); }

  // ui helpers
  function addMsg(who, text){
    const div = document.createElement('div');
    div.className = `msg ${who}`;
    div.textContent = text;
    $msgs.appendChild(div);
    $msgs.scrollTop = $msgs.scrollHeight;
  }

  // estrazione fatti molto semplice (italiano)
  function learnFrom(text){
    // nome
    let m = text.match(/\b(mi chiamo|sono)\s+([A-Za-zÀ-ÖØ-öø-ÿ'][A-Za-zÀ-ÖØ-öø-ÿ' -]{1,20})\b/i);
    if(m){ mem.name = cap(m[2].trim()); saveMem(); return `Piacere, ${mem.name}. Memorizzato.`; }

    // mi piace / adoro
    m = text.match(/\b(mi\s+piace|adoro)\s+([^\.!?]{2,40})/i);
    if(m){ const item = clean(m[2]); if(!mem.likes.includes(item)) mem.likes.push(item); saveMem();
           return `Annotato: ti piace ${item}.`; }

    // odio / non sopporto
    m = text.match(/\b(odio|non\s+sopporto)\s+([^\.!?]{2,40})/i);
    if(m){ const item = clean(m[2]); if(!mem.hates.includes(item)) mem.hates.push(item); saveMem();
           return `Ok, eviterò ${item}.`; }

    return null;
  }
  function cap(s){ return s.charAt(0).toUpperCase()+s.slice(1); }
  function clean(s){ return s.replace(/^[ ,.;:-]+|[ ,.;:-]+$/g,''); }

  // generazione risposta minimale
  function reply(text){
    // prova a imparare
    const learned = learnFrom(text);
    if(learned) return learned;

    // usa la memoria
    if(/come stai|tutto bene|ciao/i.test(text)){
      const hello = mem.name ? `Ciao ${mem.name}!` : `Ciao!`;
      const like  = mem.likes[0] ? ` So che ti piace ${mem.likes[0]}.` : '';
      return `${hello} Vuoi dirmi cosa stai cercando?${like}`;
    }

    if(/chi sei|cosa sei/i.test(text)){
      return `Sono AiLov, un'interfaccia che cresce con te. Dimmi qualcosa di te (es. “mi chiamo …”, “mi piace …”).`;
    }

    if(/cosa ricordi|che sai di me/i.test(text)){
      const parts = [];
      if(mem.name) parts.push(`ti chiami ${mem.name}`);
      if(mem.likes.length) parts.push(`ti piace ${mem.likes.join(', ')}`);
      if(mem.hates.length) parts.push(`eviti ${mem.hates.join(', ')}`);
      return parts.length ? `Ricordo che ${parts.join('; ')}.` : `Per ora non molto. Dimmi di te!`;
    }

    // fallback asciutto-coerente
    return `Ricevuto. Vuoi che lo memorizzi? Puoi dirmi “mi piace …”, “odio …” o “mi chiamo …”.`;
  }

  function send(){
    const text = ($in.value || '').trim();
    if(!text) return;
    addMsg('you', text);
    const r = reply(text);
    if(r) addMsg('ai', r);
    $in.value = '';
  }

  $send.addEventListener('click', send);
  $in.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); send(); }});

  // saluto iniziale
  addMsg('ai', mem.name ? `Bentornata/o, ${mem.name}.` : `Ciao, sono AiLov. Dimmi il tuo nome: “mi chiamo …”.`);
})();
</script>
</body>
</html>
